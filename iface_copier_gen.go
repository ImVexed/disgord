// Code generated by generate/interfaces; DO NOT EDIT.

package disgord

import "github.com/andersfylling/disgord/internal/constant"

func (c *Channel) CopyOverTo(other interface{}) (err error) {
	var cp *Channel
	var valid bool
	if cp, valid = other.(*Channel); !valid {
		err = newErrorUnsupportedType("argument given is not a *Channel type")
		return
	}

	if constant.LockedMethods {
		c.RLock()
		cp.Lock()
	}
	cp.ID = c.ID
	cp.Type = c.Type
	cp.GuildID = c.GuildID
	cp.Position = c.Position
	cp.PermissionOverwrites = c.PermissionOverwrites
	cp.Name = c.Name
	cp.Topic = c.Topic
	cp.NSFW = c.NSFW
	cp.LastMessageID = c.LastMessageID
	cp.Bitrate = c.Bitrate
	cp.UserLimit = c.UserLimit
	cp.RateLimitPerUser = c.RateLimitPerUser
	cp.Recipients = c.Recipients
	cp.Icon = c.Icon
	cp.OwnerID = c.OwnerID
	cp.ApplicationID = c.ApplicationID
	cp.ParentID = c.ParentID
	cp.LastPinTimestamp = c.LastPinTimestamp
	cp.complete = c.complete
	cp.recipientsIDs = c.recipientsIDs

	if constant.LockedMethods {
		c.RUnlock()
		cp.Unlock()
	}

	return
}

func (e *Emoji) CopyOverTo(other interface{}) (err error) {
	var cp *Emoji
	var valid bool
	if cp, valid = other.(*Emoji); !valid {
		err = newErrorUnsupportedType("argument given is not a *Emoji type")
		return
	}

	if constant.LockedMethods {
		e.RLock()
		cp.Lock()
	}
	cp.mu = e.mu
	cp.ID = e.ID
	cp.Name = e.Name
	cp.Roles = e.Roles
	if e.User != nil {
		cp.User.Reset()
		_ = e.User.CopyOverTo(cp.User)
	}
	cp.RequireColons = e.RequireColons
	cp.Managed = e.Managed
	cp.Animated = e.Animated
	cp.guildID = e.guildID

	if constant.LockedMethods {
		e.RUnlock()
		cp.Unlock()
	}

	return
}

func (g *Guild) CopyOverTo(other interface{}) (err error) {
	var cp *Guild
	var valid bool
	if cp, valid = other.(*Guild); !valid {
		err = newErrorUnsupportedType("argument given is not a *Guild type")
		return
	}

	if constant.LockedMethods {
		g.RLock()
		cp.Lock()
	}
	cp.ID = g.ID
	cp.ApplicationID = g.ApplicationID
	cp.Name = g.Name
	cp.Icon = g.Icon
	cp.Splash = g.Splash
	cp.Owner = g.Owner
	cp.OwnerID = g.OwnerID
	cp.Permissions = g.Permissions
	cp.Region = g.Region
	cp.AfkChannelID = g.AfkChannelID
	cp.AfkTimeout = g.AfkTimeout
	cp.EmbedEnabled = g.EmbedEnabled
	cp.EmbedChannelID = g.EmbedChannelID
	cp.VerificationLevel = g.VerificationLevel
	cp.DefaultMessageNotifications = g.DefaultMessageNotifications
	cp.ExplicitContentFilter = g.ExplicitContentFilter
	cp.Roles = g.Roles
	cp.Emojis = g.Emojis
	cp.Features = g.Features
	cp.MFALevel = g.MFALevel
	cp.WidgetEnabled = g.WidgetEnabled
	cp.WidgetChannelID = g.WidgetChannelID
	cp.SystemChannelID = g.SystemChannelID
	cp.JoinedAt = g.JoinedAt
	cp.Large = g.Large
	cp.Unavailable = g.Unavailable
	cp.MemberCount = g.MemberCount
	cp.VoiceStates = g.VoiceStates
	cp.Members = g.Members
	cp.Channels = g.Channels
	cp.Presences = g.Presences

	if constant.LockedMethods {
		g.RUnlock()
		cp.Unlock()
	}

	return
}

func (i *Invite) CopyOverTo(other interface{}) (err error) {
	var cp *Invite
	var valid bool
	if cp, valid = other.(*Invite); !valid {
		err = newErrorUnsupportedType("argument given is not a *Invite type")
		return
	}

	if constant.LockedMethods {
		i.RLock()
		cp.Lock()
	}
	cp.Code = i.Code
	cp.Guild = i.Guild
	cp.Channel = i.Channel
	cp.ApproximatePresenceCount = i.ApproximatePresenceCount
	cp.ApproximateMemberCount = i.ApproximateMemberCount

	if constant.LockedMethods {
		i.RUnlock()
		cp.Unlock()
	}

	return
}

func (i *InviteMetadata) CopyOverTo(other interface{}) (err error) {
	var cp *InviteMetadata
	var valid bool
	if cp, valid = other.(*InviteMetadata); !valid {
		err = newErrorUnsupportedType("argument given is not a *InviteMetadata type")
		return
	}

	if constant.LockedMethods {
		i.RLock()
		cp.Lock()
	}
	if i.Inviter != nil {
		cp.Inviter.Reset()
		_ = i.Inviter.CopyOverTo(cp.Inviter)
	}
	cp.Uses = i.Uses
	cp.MaxUses = i.MaxUses
	cp.MaxAge = i.MaxAge
	cp.Temporary = i.Temporary
	cp.CreatedAt = i.CreatedAt
	cp.Revoked = i.Revoked

	if constant.LockedMethods {
		i.RUnlock()
		cp.Unlock()
	}

	return
}

func (m *Message) CopyOverTo(other interface{}) (err error) {
	var cp *Message
	var valid bool
	if cp, valid = other.(*Message); !valid {
		err = newErrorUnsupportedType("argument given is not a *Message type")
		return
	}

	if constant.LockedMethods {
		m.RLock()
		cp.Lock()
	}
	cp.ID = m.ID
	cp.ChannelID = m.ChannelID
	if m.Author != nil {
		cp.Author.Reset()
		_ = m.Author.CopyOverTo(cp.Author)
	}
	if m.Member != nil {
		cp.Member.Reset()
		_ = m.Member.CopyOverTo(cp.Member)
	}
	cp.Content = m.Content
	cp.Timestamp = m.Timestamp
	cp.EditedTimestamp = m.EditedTimestamp
	cp.Tts = m.Tts
	cp.MentionEveryone = m.MentionEveryone
	cp.Mentions = m.Mentions
	cp.MentionRoles = m.MentionRoles
	cp.MentionChannels = m.MentionChannels
	cp.Attachments = m.Attachments
	cp.Embeds = m.Embeds
	cp.Reactions = m.Reactions
	cp.Nonce = m.Nonce
	cp.Pinned = m.Pinned
	cp.WebhookID = m.WebhookID
	cp.Type = m.Type
	cp.Activity = m.Activity
	cp.Application = m.Application
	cp.MessageReference = m.MessageReference
	cp.Flags = m.Flags
	cp.GuildID = m.GuildID
	cp.SpoilerTagContent = m.SpoilerTagContent
	cp.SpoilerTagAllAttachments = m.SpoilerTagAllAttachments
	cp.HasSpoilerImage = m.HasSpoilerImage

	if constant.LockedMethods {
		m.RUnlock()
		cp.Unlock()
	}

	return
}

func (r *Role) CopyOverTo(other interface{}) (err error) {
	var cp *Role
	var valid bool
	if cp, valid = other.(*Role); !valid {
		err = newErrorUnsupportedType("argument given is not a *Role type")
		return
	}

	if constant.LockedMethods {
		r.RLock()
		cp.Lock()
	}
	cp.ID = r.ID
	cp.Name = r.Name
	cp.Color = r.Color
	cp.Hoist = r.Hoist
	cp.Position = r.Position
	cp.Permissions = r.Permissions
	cp.Managed = r.Managed
	cp.Mentionable = r.Mentionable
	cp.guildID = r.guildID

	if constant.LockedMethods {
		r.RUnlock()
		cp.Unlock()
	}

	return
}

func (u *User) CopyOverTo(other interface{}) (err error) {
	var cp *User
	var valid bool
	if cp, valid = other.(*User); !valid {
		err = newErrorUnsupportedType("argument given is not a *User type")
		return
	}

	if constant.LockedMethods {
		u.RLock()
		cp.Lock()
	}
	cp.ID = u.ID
	cp.Username = u.Username
	cp.Discriminator = u.Discriminator
	cp.Email = u.Email
	cp.Avatar = u.Avatar
	cp.Token = u.Token
	cp.Verified = u.Verified
	cp.MFAEnabled = u.MFAEnabled
	cp.Bot = u.Bot
	cp.PremiumType = u.PremiumType
	cp.overwritten = u.overwritten

	if constant.LockedMethods {
		u.RUnlock()
		cp.Unlock()
	}

	return
}

func (v *VoiceState) CopyOverTo(other interface{}) (err error) {
	var cp *VoiceState
	var valid bool
	if cp, valid = other.(*VoiceState); !valid {
		err = newErrorUnsupportedType("argument given is not a *VoiceState type")
		return
	}

	if constant.LockedMethods {
		v.RLock()
		cp.Lock()
	}
	cp.GuildID = v.GuildID
	cp.ChannelID = v.ChannelID
	cp.UserID = v.UserID
	if v.Member != nil {
		cp.Member.Reset()
		_ = v.Member.CopyOverTo(cp.Member)
	}
	cp.SessionID = v.SessionID
	cp.Deaf = v.Deaf
	cp.Mute = v.Mute
	cp.SelfDeaf = v.SelfDeaf
	cp.SelfMute = v.SelfMute
	cp.Suppress = v.Suppress

	if constant.LockedMethods {
		v.RUnlock()
		cp.Unlock()
	}

	return
}

func (v *VoiceRegion) CopyOverTo(other interface{}) (err error) {
	var cp *VoiceRegion
	var valid bool
	if cp, valid = other.(*VoiceRegion); !valid {
		err = newErrorUnsupportedType("argument given is not a *VoiceRegion type")
		return
	}

	if constant.LockedMethods {
		v.RLock()
		cp.Lock()
	}
	cp.ID = v.ID
	cp.Name = v.Name
	cp.SampleHostname = v.SampleHostname
	cp.SamplePort = v.SamplePort
	cp.VIP = v.VIP
	cp.Optimal = v.Optimal
	cp.Deprecated = v.Deprecated
	cp.Custom = v.Custom

	if constant.LockedMethods {
		v.RUnlock()
		cp.Unlock()
	}

	return
}
